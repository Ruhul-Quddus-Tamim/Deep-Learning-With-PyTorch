# -*- coding: utf-8 -*-
"""Time Series Forecasting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K6dE6Sek_6NrrwefzuirJliIoLwmL47Z
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sn

df  = pd.read_csv("PJME_hourly.csv")
df.head()

dataset = df
dataset["Month"] = pd.to_datetime(df["Datetime"]).dt.month
dataset["Year"] = pd.to_datetime(df["Datetime"]).dt.year
dataset["Date"] = pd.to_datetime(df["Datetime"]).dt.date
dataset["Time"] = pd.to_datetime(df["Datetime"]).dt.time
dataset["Week"] = pd.to_datetime(df["Datetime"]).dt.week
dataset["Day"] = pd.to_datetime(df["Datetime"]).dt.day_name()
dataset = df.set_index("Datetime")
dataset.index = pd.to_datetime(dataset.index)
dataset.head(10)

print(df.Year.unique(),"\n")
print("Total Number of Unique Year", df.Year.nunique(), "\n")

color_plot = sn.color_palette()
power.plot(style = '.', figsize = (15, 15), color = color_plot[0], title = 'Energy Consumption in MW')

from matplotlib import style

fig = plt.figure()
ax1 = plt.subplot2grid((1,1), (0,0))

style.use('ggplot')

sn.lineplot(x=df["Year"], y=df["PJME_MW"], data=df)
sn.set(rc={'figure.figsize':(20,10)})

plt.title("Energy consumptionnin Year 2004")
plt.xlabel("Date")
plt.ylabel("Energy in MW")
plt.grid(True)
plt.legend()

for label in ax1.xaxis.get_ticklabels():
    label.set_rotation(90)


plt.title("Energy Consumption According to Year")

from matplotlib import style


fig = plt.figure()

ax1= fig.add_subplot(311)
ax2= fig.add_subplot(312)
ax3= fig.add_subplot(313)


style.use('ggplot')

y_2004 = dataset.loc["2004"]["PJME_MW"].to_list()
x_2004 = dataset.loc["2004"]["Date"].to_list()
ax1.plot(x_2004,y_2004, color="green", linewidth=1.7)


y_2005 = dataset.loc["2005"]["PJME_MW"].to_list()
x_2005 = dataset.loc["2005"]["Date"].to_list()
ax2.plot(x_2005, y_2005, color="green", linewidth=1)


y_2006 = dataset.loc["2006"]["PJME_MW"].to_list()
x_2006 = dataset.loc["2006"]["Date"].to_list()
ax3.plot(x_2006, y_2006, color="green", linewidth=1)


plt.rcParams["figure.figsize"] = (20,10)
plt.title("Energy consumptionnin")
plt.xlabel("Date")
plt.ylabel("Energy in MW")
plt.grid(True, alpha=1)
plt.legend()

for label in ax1.xaxis.get_ticklabels():
    label.set_rotation(90)

sn.distplot(dataset["PJME_MW"])
plt.title("Energy Distribution")

fig = plt.figure()
ax1= fig.add_subplot(111)

sn.lineplot(x = df["Month"], y = df["PJME_MW"], data = df)
# sns.relplot(data=df, x="Time", y="AEP_MW", kind="line")
plt.title("Energy Consumption vs Time ")
plt.xlabel("Time")
plt.grid(True, alpha=1)
plt.legend()

for label in ax1.xaxis.get_ticklabels():
    label.set_rotation(90)

def datasets(df, window_size = 23):
  X = []
  Y = []

  for i in range(len(df) - window_size):
    row = [[a] for a in df[i:i+23]]
    X.append(row)
    label = df[i+23]
    Y.append(label)

  return np.array(X), np.array(Y)

from sklearn.preprocessing import MinMaxScaler
Window_size = 23

power_df = dataset.iloc[:,0:1]

sc = MinMaxScaler(feature_range=(0, 1))

power_df = sc.fit_transform(power_df)

print(len(power_df), power_df.shape)
X, y = datasets(power_df, Window_size)

print(X.shape,'\n',y.shape)

X_train, y_train = X[:110000], y[:110000]
X_val, y_val = X[110000:110500], y[110000:110500]
X_test, y_test = X[110500:], y[110500:]

X_Train = np.reshape(X_train, newshape=(X_train.shape[0], X_train.shape[1], 1))
X_Val = np.reshape(X_val, newshape=(X_val.shape[0], X_val.shape[1], 1))
X_Test = np.reshape(X_test, newshape=(X_test.shape[0], X_test.shape[1], 1))

X_Train.shape, X_Val.shape, X_Test.shape

X_Train[1].shape

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import *
from tensorflow.keras.callbacks import ModelCheckpoint
from tensorflow.keras.losses import MeanSquaredError
from tensorflow.keras.metrics import RootMeanSquaredError
from tensorflow.keras.optimizers import Adam

model = Sequential()

model.add(LSTM(units = 23, return_sequences = True, input_shape = (X_Train.shape[1], 1)))
model.add(Dropout(0.2))

# Adding a second LSTM layer and some Dropout regularisation
model.add(LSTM(units = 23, return_sequences = True))
model.add(Dropout(0.2))

# Adding a third LSTM layer and some Dropout regularisation
model.add(LSTM(units = 23, return_sequences = True))
model.add(Dropout(0.2))

# Adding a fourth LSTM layer and some Dropout regularisation
model.add(LSTM(units = 23))
model.add(Dropout(0.2))

# Adding the output layer
model.add(Dense(units = 1))

model.summary()

checkpoint = ModelCheckpoint('Saved_Model/', save_best_only = True)
model.compile(loss=MeanSquaredError(), optimizer=Adam(learning_rate=0.0001), metrics=[RootMeanSquaredError()])

model.fit(X_Train, y_train, validation_data=(X_Val, y_val), epochs=10, callbacks=[checkpoint], batch_size=32)

test_predictions = model.predict(X_Test)
test_predictions

# Inverse Transformation to get Values 
predicted_price = sc.inverse_transform(test_predictions)
predicted_price.flatten()

True_MegaWatt = y_test
True_MegaWatt = sc.inverse_transform(True_MegaWatt)
Predicted_MegaWatt  = predicted_price
True_MegaWatt = True_MegaWatt.flatten()

Machine_Df = pd.DataFrame(data={
    "TrueMegaWatt": True_MegaWatt,
    "PredictedMeagWatt":[x[0] for x in Predicted_MegaWatt]
})

Machine_Df

plt.plot(Machine_Df['PredictedMeagWatt'][:150])
plt.plot(Machine_Df['TrueMegaWatt'][:150])